### makeCacheMatrix creates a cacheable matrix that serves as input the function cachesolve wich gets the cached matrix or solves the inverse in case it doesnt exist

makeCacheMatrix <- function(input = matrix()) {
        
        # First, we check that the input object is of class matrix
        if(!is.matrix(input)) {
                stop('Object must be a squared matrix')
        }
        
        # We set the inverted matrix to null as a placeholder for a future value
        inverted <- NULL
        
        #we define the function set to set the matrix "input" to a new matrix "y" and resets the inverted matrix "inverted" to NULL.
        set <- function(y){
                input <<- y
                inverted <<- NULL
        }
        
        #returns the matrix "input"
        get<- function() input 
        
        
        #set the inverse using solve()
        set.inv <- function(solve) inverted <<- solve
        
        #returns the inverted matrix
        get.inv <- function() inverted
        
        # retuns all the functions just defined
        list(set = set, get = get, set.inv = set.inv, get.inv=get.inv )
}


### Cachesolve computes the inverse of the cacheable matrix generated by makeCacheMatrix(). When the input matrix has already been passed to cacheSolve and 
# remains the same cachesolve returns the cached data. 


cacheSolve <- function(input,...) {
        inverted <- input$get.inv()
        # We check if the matrix is cached
        if(!is.null(inverted)) {
                message("getting cached data")
                return(inverted)
        }
        #If theres no cached matrix computes the inverse with the solve() function
        data <- input$get()
        inverted<- solve(data,...)
        input$set.inv(inverted)
        inverted
}
### Test case
input <- matrix(c(1,0,2,-1,1,0,0,0,1),3,3)

specialmatrix <- makeCacheMatrix(input)

cacheSolve(specialmatrix)
